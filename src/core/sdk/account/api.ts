/* tslint:disable */
/* eslint-disable */
/**
 * Account Docs
 * Account endpoints...
 *
 * The version of the OpenAPI document: 1.0
 * 
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */


import type { Configuration } from './configuration';
import type { AxiosPromise, AxiosInstance, RawAxiosRequestConfig } from 'axios';
import globalAxios from 'axios';
// Some imports not used depending on template conditions
// @ts-ignore
import { DUMMY_BASE_URL, assertParamExists, setApiKeyToObject, setBasicAuthToObject, setBearerAuthToObject, setOAuthToObject, setSearchParams, serializeDataIfNeeded, toPathString, createRequestFunction } from './common';
import type { RequestArgs } from './base';
// @ts-ignore
import { BASE_PATH, COLLECTION_FORMATS, BaseAPI, RequiredError, operationServerMap } from './base';

/**
 * 
 * @export
 * @interface AccountInfo
 */
export interface AccountInfo {
    /**
     * 
     * @type {string}
     * @memberof AccountInfo
     */
    'id': string;
    /**
     * 
     * @type {string}
     * @memberof AccountInfo
     */
    'firstName': string;
    /**
     * 
     * @type {string}
     * @memberof AccountInfo
     */
    'lastName': string;
    /**
     * 
     * @type {string}
     * @memberof AccountInfo
     */
    'phone': string;
    /**
     * 
     * @type {string}
     * @memberof AccountInfo
     */
    'email': string;
    /**
     * 
     * @type {string}
     * @memberof AccountInfo
     */
    'state': string;
    /**
     * 
     * @type {string}
     * @memberof AccountInfo
     */
    'stateArea': string;
    /**
     * 
     * @type {string}
     * @memberof AccountInfo
     */
    'latitude': string;
    /**
     * 
     * @type {string}
     * @memberof AccountInfo
     */
    'longitude': string;
    /**
     * 
     * @type {string}
     * @memberof AccountInfo
     */
    'profilePhoto': string;
    /**
     * 
     * @type {string}
     * @memberof AccountInfo
     */
    'accountType': AccountInfoAccountTypeEnum;
    /**
     * 
     * @type {string}
     * @memberof AccountInfo
     */
    'status': AccountInfoStatusEnum;
    /**
     * 
     * @type {string}
     * @memberof AccountInfo
     */
    'fcmToken': string;
    /**
     * 
     * @type {string}
     * @memberof AccountInfo
     */
    'referralCode': string;
    /**
     * 
     * @type {string}
     * @memberof AccountInfo
     */
    'referredBy': string;
    /**
     * 
     * @type {string}
     * @memberof AccountInfo
     */
    'lastLogin': string;
    /**
     * 
     * @type {string}
     * @memberof AccountInfo
     */
    'lastDonationDate': string;
    /**
     * 
     * @type {boolean}
     * @memberof AccountInfo
     */
    'inRecovery': boolean;
    /**
     * 
     * @type {string}
     * @memberof AccountInfo
     */
    'bloodGroup': AccountInfoBloodGroupEnum;
    /**
     * 
     * @type {string}
     * @memberof AccountInfo
     */
    'genotype': AccountInfoGenotypeEnum;
    /**
     * 
     * @type {boolean}
     * @memberof AccountInfo
     */
    'hasTattoos': boolean;
    /**
     * 
     * @type {boolean}
     * @memberof AccountInfo
     */
    'isComplianceUploaded': boolean;
}

export const AccountInfoAccountTypeEnum = {
    DonationCenter: 'donation_center',
    Individual: 'individual',
    Admin: 'admin',
    SuperAdmin: 'super_admin',
    System: 'system'
} as const;

export type AccountInfoAccountTypeEnum = typeof AccountInfoAccountTypeEnum[keyof typeof AccountInfoAccountTypeEnum];
export const AccountInfoStatusEnum = {
    Pending: 'pending',
    Active: 'active',
    Inactive: 'inactive',
    ShadowBanned: 'shadow_banned',
    Disabled: 'disabled'
} as const;

export type AccountInfoStatusEnum = typeof AccountInfoStatusEnum[keyof typeof AccountInfoStatusEnum];
export const AccountInfoBloodGroupEnum = {
    A: 'A+',
    A2: 'A-',
    B: 'B+',
    B2: 'B-',
    Ab: 'AB+',
    Ab2: 'AB-',
    O: 'O+',
    O2: 'O-'
} as const;

export type AccountInfoBloodGroupEnum = typeof AccountInfoBloodGroupEnum[keyof typeof AccountInfoBloodGroupEnum];
export const AccountInfoGenotypeEnum = {
    Aa: 'AA',
    As: 'AS',
    Ss: 'SS',
    Ac: 'AC',
    Sc: 'SC'
} as const;

export type AccountInfoGenotypeEnum = typeof AccountInfoGenotypeEnum[keyof typeof AccountInfoGenotypeEnum];

/**
 * 
 * @export
 * @interface AddListItemDTO
 */
export interface AddListItemDTO {
    /**
     * ID of the item.
     * @type {string}
     * @memberof AddListItemDTO
     */
    'itemId': string;
    /**
     * Type of the list item.
     * @type {string}
     * @memberof AddListItemDTO
     */
    'itemType': AddListItemDTOItemTypeEnum;
    /**
     * Type of the list entity.
     * @type {string}
     * @memberof AddListItemDTO
     */
    'entityType': AddListItemDTOEntityTypeEnum;
}

export const AddListItemDTOItemTypeEnum = {
    Favorite: 'favorite',
    Like: 'like',
    Viewed: 'viewed',
    Wishlist: 'wishlist',
    SearchHistoryEntry: 'search-history-entry'
} as const;

export type AddListItemDTOItemTypeEnum = typeof AddListItemDTOItemTypeEnum[keyof typeof AddListItemDTOItemTypeEnum];
export const AddListItemDTOEntityTypeEnum = {
    DonationCenter: 'donation-center',
    Campaign: 'campaign'
} as const;

export type AddListItemDTOEntityTypeEnum = typeof AddListItemDTOEntityTypeEnum[keyof typeof AddListItemDTOEntityTypeEnum];

/**
 * 
 * @export
 * @interface ContactUsDTO
 */
export interface ContactUsDTO {
    /**
     * The name of the user
     * @type {string}
     * @memberof ContactUsDTO
     */
    'name': string;
    /**
     * The email of the user
     * @type {string}
     * @memberof ContactUsDTO
     */
    'email': string;
    /**
     * The subject of the message
     * @type {string}
     * @memberof ContactUsDTO
     */
    'subject': string;
    /**
     * The message from the user
     * @type {string}
     * @memberof ContactUsDTO
     */
    'message': string;
}
/**
 * 
 * @export
 * @interface DeleteAccountDTO
 */
export interface DeleteAccountDTO {
    /**
     * Current account password.
     * @type {string}
     * @memberof DeleteAccountDTO
     */
    'password': string;
}
/**
 * 
 * @export
 * @interface FileUploadResult
 */
export interface FileUploadResult {
    /**
     * 
     * @type {string}
     * @memberof FileUploadResult
     */
    'url': string;
    /**
     * 
     * @type {string}
     * @memberof FileUploadResult
     */
    'public_id': string;
}
/**
 * 
 * @export
 * @interface ListItemInfo
 */
export interface ListItemInfo {
    /**
     * List Item ID
     * @type {string}
     * @memberof ListItemInfo
     */
    'id': string;
    /**
     * List Item Type
     * @type {string}
     * @memberof ListItemInfo
     */
    'itemType': ListItemInfoItemTypeEnum;
    /**
     * ID of the item.
     * @type {string}
     * @memberof ListItemInfo
     */
    'itemId': string;
    /**
     * Type of the list entity.
     * @type {string}
     * @memberof ListItemInfo
     */
    'entityType': ListItemInfoEntityTypeEnum;
}

export const ListItemInfoItemTypeEnum = {
    Favorite: 'favorite',
    Like: 'like',
    Viewed: 'viewed',
    Wishlist: 'wishlist',
    SearchHistoryEntry: 'search-history-entry'
} as const;

export type ListItemInfoItemTypeEnum = typeof ListItemInfoItemTypeEnum[keyof typeof ListItemInfoItemTypeEnum];
export const ListItemInfoEntityTypeEnum = {
    DonationCenter: 'donation-center',
    Campaign: 'campaign'
} as const;

export type ListItemInfoEntityTypeEnum = typeof ListItemInfoEntityTypeEnum[keyof typeof ListItemInfoEntityTypeEnum];

/**
 * 
 * @export
 * @interface MedicalHistoryInfo
 */
export interface MedicalHistoryInfo {
    /**
     * 
     * @type {string}
     * @memberof MedicalHistoryInfo
     */
    'id': string;
    /**
     * 
     * @type {string}
     * @memberof MedicalHistoryInfo
     */
    'bloodGroup': string;
    /**
     * 
     * @type {string}
     * @memberof MedicalHistoryInfo
     */
    'genotype': string;
    /**
     * 
     * @type {boolean}
     * @memberof MedicalHistoryInfo
     */
    'hiv1': boolean;
    /**
     * 
     * @type {boolean}
     * @memberof MedicalHistoryInfo
     */
    'hiv2': boolean;
    /**
     * 
     * @type {boolean}
     * @memberof MedicalHistoryInfo
     */
    'hepatitisB': boolean;
    /**
     * 
     * @type {boolean}
     * @memberof MedicalHistoryInfo
     */
    'hepatitisC': boolean;
    /**
     * 
     * @type {boolean}
     * @memberof MedicalHistoryInfo
     */
    'syphilis': boolean;
    /**
     * 
     * @type {string}
     * @memberof MedicalHistoryInfo
     */
    'appointmentId': string;
    /**
     * 
     * @type {string}
     * @memberof MedicalHistoryInfo
     */
    'centerName': string;
    /**
     * 
     * @type {string}
     * @memberof MedicalHistoryInfo
     */
    'centerCoverPhoto': string;
    /**
     * 
     * @type {string}
     * @memberof MedicalHistoryInfo
     */
    'centerAddress': string;
    /**
     * 
     * @type {string}
     * @memberof MedicalHistoryInfo
     */
    'centerPhone': string;
    /**
     * 
     * @type {string}
     * @memberof MedicalHistoryInfo
     */
    'centerEmail': string;
    /**
     * 
     * @type {string}
     * @memberof MedicalHistoryInfo
     */
    'centerLatitude': string;
    /**
     * 
     * @type {string}
     * @memberof MedicalHistoryInfo
     */
    'centerLongitude': string;
    /**
     * 
     * @type {string}
     * @memberof MedicalHistoryInfo
     */
    'createdAt': string;
}
/**
 * 
 * @export
 * @interface NotificationInfo
 */
export interface NotificationInfo {
    /**
     * Notification ID
     * @type {string}
     * @memberof NotificationInfo
     */
    'id'?: string;
    /**
     * Notification subject
     * @type {string}
     * @memberof NotificationInfo
     */
    'subject'?: string;
    /**
     * Notification message
     * @type {string}
     * @memberof NotificationInfo
     */
    'message'?: string;
    /**
     * Notification type
     * @type {string}
     * @memberof NotificationInfo
     */
    'type'?: NotificationInfoTypeEnum;
    /**
     * Appointment ID
     * @type {string}
     * @memberof NotificationInfo
     */
    'appointment'?: string;
    /**
     * Notification is read
     * @type {boolean}
     * @memberof NotificationInfo
     */
    'isRead'?: boolean;
}

export const NotificationInfoTypeEnum = {
    Default: 'default',
    SupportInquiry: 'support_inquiry',
    AppointmentReminder: 'appointment_reminder',
    AppointmentConfirmation: 'appointment_confirmation'
} as const;

export type NotificationInfoTypeEnum = typeof NotificationInfoTypeEnum[keyof typeof NotificationInfoTypeEnum];

/**
 * 
 * @export
 * @interface UpdateAccountEmailDTO
 */
export interface UpdateAccountEmailDTO {
    /**
     * New account email.
     * @type {string}
     * @memberof UpdateAccountEmailDTO
     */
    'newEmail': string;
}
/**
 * 
 * @export
 * @interface UpdateAccountNameDTO
 */
export interface UpdateAccountNameDTO {
    /**
     * New account first name.
     * @type {string}
     * @memberof UpdateAccountNameDTO
     */
    'firstName': string;
    /**
     * New account last name.
     * @type {string}
     * @memberof UpdateAccountNameDTO
     */
    'lastName': string;
}
/**
 * 
 * @export
 * @interface UpdateAccountPasswordDTO
 */
export interface UpdateAccountPasswordDTO {
    /**
     * Current account password.
     * @type {string}
     * @memberof UpdateAccountPasswordDTO
     */
    'currentPassword': string;
    /**
     * New account password.
     * @type {string}
     * @memberof UpdateAccountPasswordDTO
     */
    'newPassword': string;
}
/**
 * 
 * @export
 * @interface UpdateAccountPhoneDTO
 */
export interface UpdateAccountPhoneDTO {
    /**
     * New account phone.
     * @type {string}
     * @memberof UpdateAccountPhoneDTO
     */
    'newPhone': string;
    /**
     * Account password.
     * @type {string}
     * @memberof UpdateAccountPhoneDTO
     */
    'password': string;
}
/**
 * 
 * @export
 * @interface UpdateFCMTokenDTO
 */
export interface UpdateFCMTokenDTO {
    /**
     * FCM token for push notifications generated by mobile device.
     * @type {string}
     * @memberof UpdateFCMTokenDTO
     */
    'fcmToken': string;
}
/**
 * 
 * @export
 * @interface UpdateProfileImageDTO
 */
export interface UpdateProfileImageDTO {
    /**
     * URL of the image to be uploaded.
     * @type {string}
     * @memberof UpdateProfileImageDTO
     */
    'imageUrl': string;
}
/**
 * 
 * @export
 * @interface VerifyNewAccountEmailDTO
 */
export interface VerifyNewAccountEmailDTO {
    /**
     * Activation token (OTP)
     * @type {string}
     * @memberof VerifyNewAccountEmailDTO
     */
    'otp': string;
}

/**
 * ManageContactInfoApi - axios parameter creator
 * @export
 */
export const ManageContactInfoApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @param {UpdateAccountEmailDTO} updateAccountEmailDTO 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        accountControllerUpdateAccountEmail: async (updateAccountEmailDTO: UpdateAccountEmailDTO, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'updateAccountEmailDTO' is not null or undefined
            assertParamExists('accountControllerUpdateAccountEmail', 'updateAccountEmailDTO', updateAccountEmailDTO)
            const localVarPath = `/v1/account/me/update-email`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(updateAccountEmailDTO, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {UpdateAccountNameDTO} updateAccountNameDTO 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        accountControllerUpdateAccountName: async (updateAccountNameDTO: UpdateAccountNameDTO, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'updateAccountNameDTO' is not null or undefined
            assertParamExists('accountControllerUpdateAccountName', 'updateAccountNameDTO', updateAccountNameDTO)
            const localVarPath = `/v1/account/me/update-name`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(updateAccountNameDTO, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {UpdateAccountPhoneDTO} updateAccountPhoneDTO 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        accountControllerUpdateAccountPhone: async (updateAccountPhoneDTO: UpdateAccountPhoneDTO, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'updateAccountPhoneDTO' is not null or undefined
            assertParamExists('accountControllerUpdateAccountPhone', 'updateAccountPhoneDTO', updateAccountPhoneDTO)
            const localVarPath = `/v1/account/me/update-phone`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(updateAccountPhoneDTO, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {VerifyNewAccountEmailDTO} verifyNewAccountEmailDTO 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        accountControllerVerifyNewAccountEmail: async (verifyNewAccountEmailDTO: VerifyNewAccountEmailDTO, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'verifyNewAccountEmailDTO' is not null or undefined
            assertParamExists('accountControllerVerifyNewAccountEmail', 'verifyNewAccountEmailDTO', verifyNewAccountEmailDTO)
            const localVarPath = `/v1/account/me/verify-new-email`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(verifyNewAccountEmailDTO, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * ManageContactInfoApi - functional programming interface
 * @export
 */
export const ManageContactInfoApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = ManageContactInfoApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @param {UpdateAccountEmailDTO} updateAccountEmailDTO 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async accountControllerUpdateAccountEmail(updateAccountEmailDTO: UpdateAccountEmailDTO, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.accountControllerUpdateAccountEmail(updateAccountEmailDTO, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ManageContactInfoApi.accountControllerUpdateAccountEmail']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {UpdateAccountNameDTO} updateAccountNameDTO 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async accountControllerUpdateAccountName(updateAccountNameDTO: UpdateAccountNameDTO, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<AccountInfo>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.accountControllerUpdateAccountName(updateAccountNameDTO, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ManageContactInfoApi.accountControllerUpdateAccountName']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {UpdateAccountPhoneDTO} updateAccountPhoneDTO 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async accountControllerUpdateAccountPhone(updateAccountPhoneDTO: UpdateAccountPhoneDTO, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<AccountInfo>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.accountControllerUpdateAccountPhone(updateAccountPhoneDTO, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ManageContactInfoApi.accountControllerUpdateAccountPhone']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {VerifyNewAccountEmailDTO} verifyNewAccountEmailDTO 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async accountControllerVerifyNewAccountEmail(verifyNewAccountEmailDTO: VerifyNewAccountEmailDTO, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<AccountInfo>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.accountControllerVerifyNewAccountEmail(verifyNewAccountEmailDTO, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ManageContactInfoApi.accountControllerVerifyNewAccountEmail']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * ManageContactInfoApi - factory interface
 * @export
 */
export const ManageContactInfoApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = ManageContactInfoApiFp(configuration)
    return {
        /**
         * 
         * @param {UpdateAccountEmailDTO} updateAccountEmailDTO 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        accountControllerUpdateAccountEmail(updateAccountEmailDTO: UpdateAccountEmailDTO, options?: RawAxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.accountControllerUpdateAccountEmail(updateAccountEmailDTO, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {UpdateAccountNameDTO} updateAccountNameDTO 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        accountControllerUpdateAccountName(updateAccountNameDTO: UpdateAccountNameDTO, options?: RawAxiosRequestConfig): AxiosPromise<AccountInfo> {
            return localVarFp.accountControllerUpdateAccountName(updateAccountNameDTO, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {UpdateAccountPhoneDTO} updateAccountPhoneDTO 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        accountControllerUpdateAccountPhone(updateAccountPhoneDTO: UpdateAccountPhoneDTO, options?: RawAxiosRequestConfig): AxiosPromise<AccountInfo> {
            return localVarFp.accountControllerUpdateAccountPhone(updateAccountPhoneDTO, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {VerifyNewAccountEmailDTO} verifyNewAccountEmailDTO 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        accountControllerVerifyNewAccountEmail(verifyNewAccountEmailDTO: VerifyNewAccountEmailDTO, options?: RawAxiosRequestConfig): AxiosPromise<AccountInfo> {
            return localVarFp.accountControllerVerifyNewAccountEmail(verifyNewAccountEmailDTO, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * ManageContactInfoApi - object-oriented interface
 * @export
 * @class ManageContactInfoApi
 * @extends {BaseAPI}
 */
export class ManageContactInfoApi extends BaseAPI {
    /**
     * 
     * @param {UpdateAccountEmailDTO} updateAccountEmailDTO 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ManageContactInfoApi
     */
    public accountControllerUpdateAccountEmail(updateAccountEmailDTO: UpdateAccountEmailDTO, options?: RawAxiosRequestConfig) {
        return ManageContactInfoApiFp(this.configuration).accountControllerUpdateAccountEmail(updateAccountEmailDTO, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {UpdateAccountNameDTO} updateAccountNameDTO 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ManageContactInfoApi
     */
    public accountControllerUpdateAccountName(updateAccountNameDTO: UpdateAccountNameDTO, options?: RawAxiosRequestConfig) {
        return ManageContactInfoApiFp(this.configuration).accountControllerUpdateAccountName(updateAccountNameDTO, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {UpdateAccountPhoneDTO} updateAccountPhoneDTO 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ManageContactInfoApi
     */
    public accountControllerUpdateAccountPhone(updateAccountPhoneDTO: UpdateAccountPhoneDTO, options?: RawAxiosRequestConfig) {
        return ManageContactInfoApiFp(this.configuration).accountControllerUpdateAccountPhone(updateAccountPhoneDTO, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {VerifyNewAccountEmailDTO} verifyNewAccountEmailDTO 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ManageContactInfoApi
     */
    public accountControllerVerifyNewAccountEmail(verifyNewAccountEmailDTO: VerifyNewAccountEmailDTO, options?: RawAxiosRequestConfig) {
        return ManageContactInfoApiFp(this.configuration).accountControllerVerifyNewAccountEmail(verifyNewAccountEmailDTO, options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * MeApi - axios parameter creator
 * @export
 */
export const MeApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @param {DeleteAccountDTO} deleteAccountDTO 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        accountControllerDeleteAccount: async (deleteAccountDTO: DeleteAccountDTO, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'deleteAccountDTO' is not null or undefined
            assertParamExists('accountControllerDeleteAccount', 'deleteAccountDTO', deleteAccountDTO)
            const localVarPath = `/v1/account/me/delete`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(deleteAccountDTO, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        accountControllerGetDetailedAccountInfo: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/v1/account/me/detailed`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {UpdateAccountPasswordDTO} updateAccountPasswordDTO 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        accountControllerUpdateAccountPassword: async (updateAccountPasswordDTO: UpdateAccountPasswordDTO, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'updateAccountPasswordDTO' is not null or undefined
            assertParamExists('accountControllerUpdateAccountPassword', 'updateAccountPasswordDTO', updateAccountPasswordDTO)
            const localVarPath = `/v1/account/me/update-password`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(updateAccountPasswordDTO, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {UpdateFCMTokenDTO} updateFCMTokenDTO 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        accountControllerUpdateFcmToken: async (updateFCMTokenDTO: UpdateFCMTokenDTO, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'updateFCMTokenDTO' is not null or undefined
            assertParamExists('accountControllerUpdateFcmToken', 'updateFCMTokenDTO', updateFCMTokenDTO)
            const localVarPath = `/v1/account/me/update-fcm-token`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(updateFCMTokenDTO, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {UpdateProfileImageDTO} updateProfileImageDTO 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        accountControllerUpdateProfileImage: async (updateProfileImageDTO: UpdateProfileImageDTO, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'updateProfileImageDTO' is not null or undefined
            assertParamExists('accountControllerUpdateProfileImage', 'updateProfileImageDTO', updateProfileImageDTO)
            const localVarPath = `/v1/account/me/update-profile-image`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(updateProfileImageDTO, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * MeApi - functional programming interface
 * @export
 */
export const MeApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = MeApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @param {DeleteAccountDTO} deleteAccountDTO 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async accountControllerDeleteAccount(deleteAccountDTO: DeleteAccountDTO, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.accountControllerDeleteAccount(deleteAccountDTO, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['MeApi.accountControllerDeleteAccount']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async accountControllerGetDetailedAccountInfo(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<AccountInfo>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.accountControllerGetDetailedAccountInfo(options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['MeApi.accountControllerGetDetailedAccountInfo']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {UpdateAccountPasswordDTO} updateAccountPasswordDTO 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async accountControllerUpdateAccountPassword(updateAccountPasswordDTO: UpdateAccountPasswordDTO, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.accountControllerUpdateAccountPassword(updateAccountPasswordDTO, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['MeApi.accountControllerUpdateAccountPassword']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {UpdateFCMTokenDTO} updateFCMTokenDTO 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async accountControllerUpdateFcmToken(updateFCMTokenDTO: UpdateFCMTokenDTO, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.accountControllerUpdateFcmToken(updateFCMTokenDTO, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['MeApi.accountControllerUpdateFcmToken']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {UpdateProfileImageDTO} updateProfileImageDTO 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async accountControllerUpdateProfileImage(updateProfileImageDTO: UpdateProfileImageDTO, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<AccountInfo>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.accountControllerUpdateProfileImage(updateProfileImageDTO, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['MeApi.accountControllerUpdateProfileImage']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * MeApi - factory interface
 * @export
 */
export const MeApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = MeApiFp(configuration)
    return {
        /**
         * 
         * @param {DeleteAccountDTO} deleteAccountDTO 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        accountControllerDeleteAccount(deleteAccountDTO: DeleteAccountDTO, options?: RawAxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.accountControllerDeleteAccount(deleteAccountDTO, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        accountControllerGetDetailedAccountInfo(options?: RawAxiosRequestConfig): AxiosPromise<AccountInfo> {
            return localVarFp.accountControllerGetDetailedAccountInfo(options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {UpdateAccountPasswordDTO} updateAccountPasswordDTO 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        accountControllerUpdateAccountPassword(updateAccountPasswordDTO: UpdateAccountPasswordDTO, options?: RawAxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.accountControllerUpdateAccountPassword(updateAccountPasswordDTO, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {UpdateFCMTokenDTO} updateFCMTokenDTO 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        accountControllerUpdateFcmToken(updateFCMTokenDTO: UpdateFCMTokenDTO, options?: RawAxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.accountControllerUpdateFcmToken(updateFCMTokenDTO, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {UpdateProfileImageDTO} updateProfileImageDTO 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        accountControllerUpdateProfileImage(updateProfileImageDTO: UpdateProfileImageDTO, options?: RawAxiosRequestConfig): AxiosPromise<AccountInfo> {
            return localVarFp.accountControllerUpdateProfileImage(updateProfileImageDTO, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * MeApi - object-oriented interface
 * @export
 * @class MeApi
 * @extends {BaseAPI}
 */
export class MeApi extends BaseAPI {
    /**
     * 
     * @param {DeleteAccountDTO} deleteAccountDTO 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof MeApi
     */
    public accountControllerDeleteAccount(deleteAccountDTO: DeleteAccountDTO, options?: RawAxiosRequestConfig) {
        return MeApiFp(this.configuration).accountControllerDeleteAccount(deleteAccountDTO, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof MeApi
     */
    public accountControllerGetDetailedAccountInfo(options?: RawAxiosRequestConfig) {
        return MeApiFp(this.configuration).accountControllerGetDetailedAccountInfo(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {UpdateAccountPasswordDTO} updateAccountPasswordDTO 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof MeApi
     */
    public accountControllerUpdateAccountPassword(updateAccountPasswordDTO: UpdateAccountPasswordDTO, options?: RawAxiosRequestConfig) {
        return MeApiFp(this.configuration).accountControllerUpdateAccountPassword(updateAccountPasswordDTO, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {UpdateFCMTokenDTO} updateFCMTokenDTO 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof MeApi
     */
    public accountControllerUpdateFcmToken(updateFCMTokenDTO: UpdateFCMTokenDTO, options?: RawAxiosRequestConfig) {
        return MeApiFp(this.configuration).accountControllerUpdateFcmToken(updateFCMTokenDTO, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {UpdateProfileImageDTO} updateProfileImageDTO 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof MeApi
     */
    public accountControllerUpdateProfileImage(updateProfileImageDTO: UpdateProfileImageDTO, options?: RawAxiosRequestConfig) {
        return MeApiFp(this.configuration).accountControllerUpdateProfileImage(updateProfileImageDTO, options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * MedicalHistoryApi - axios parameter creator
 * @export
 */
export const MedicalHistoryApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        accountControllerGetMedicalHistory: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/v1/account/me/medical-history`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * MedicalHistoryApi - functional programming interface
 * @export
 */
export const MedicalHistoryApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = MedicalHistoryApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async accountControllerGetMedicalHistory(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<MedicalHistoryInfo>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.accountControllerGetMedicalHistory(options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['MedicalHistoryApi.accountControllerGetMedicalHistory']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * MedicalHistoryApi - factory interface
 * @export
 */
export const MedicalHistoryApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = MedicalHistoryApiFp(configuration)
    return {
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        accountControllerGetMedicalHistory(options?: RawAxiosRequestConfig): AxiosPromise<Array<MedicalHistoryInfo>> {
            return localVarFp.accountControllerGetMedicalHistory(options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * MedicalHistoryApi - object-oriented interface
 * @export
 * @class MedicalHistoryApi
 * @extends {BaseAPI}
 */
export class MedicalHistoryApi extends BaseAPI {
    /**
     * 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof MedicalHistoryApi
     */
    public accountControllerGetMedicalHistory(options?: RawAxiosRequestConfig) {
        return MedicalHistoryApiFp(this.configuration).accountControllerGetMedicalHistory(options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * NotificationsApi - axios parameter creator
 * @export
 */
export const NotificationsApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        accountControllerGetNotifications: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/v1/account/me/notifications`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * NotificationsApi - functional programming interface
 * @export
 */
export const NotificationsApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = NotificationsApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async accountControllerGetNotifications(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<NotificationInfo>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.accountControllerGetNotifications(options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['NotificationsApi.accountControllerGetNotifications']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * NotificationsApi - factory interface
 * @export
 */
export const NotificationsApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = NotificationsApiFp(configuration)
    return {
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        accountControllerGetNotifications(options?: RawAxiosRequestConfig): AxiosPromise<Array<NotificationInfo>> {
            return localVarFp.accountControllerGetNotifications(options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * NotificationsApi - object-oriented interface
 * @export
 * @class NotificationsApi
 * @extends {BaseAPI}
 */
export class NotificationsApi extends BaseAPI {
    /**
     * 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof NotificationsApi
     */
    public accountControllerGetNotifications(options?: RawAxiosRequestConfig) {
        return NotificationsApiFp(this.configuration).accountControllerGetNotifications(options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * SupportApi - axios parameter creator
 * @export
 */
export const SupportApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @param {ContactUsDTO} contactUsDTO 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        supportControllerContactUs: async (contactUsDTO: ContactUsDTO, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'contactUsDTO' is not null or undefined
            assertParamExists('supportControllerContactUs', 'contactUsDTO', contactUsDTO)
            const localVarPath = `/v1/account/support/contact-us`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(contactUsDTO, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * SupportApi - functional programming interface
 * @export
 */
export const SupportApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = SupportApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @param {ContactUsDTO} contactUsDTO 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async supportControllerContactUs(contactUsDTO: ContactUsDTO, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.supportControllerContactUs(contactUsDTO, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['SupportApi.supportControllerContactUs']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * SupportApi - factory interface
 * @export
 */
export const SupportApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = SupportApiFp(configuration)
    return {
        /**
         * 
         * @param {ContactUsDTO} contactUsDTO 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        supportControllerContactUs(contactUsDTO: ContactUsDTO, options?: RawAxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.supportControllerContactUs(contactUsDTO, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * SupportApi - object-oriented interface
 * @export
 * @class SupportApi
 * @extends {BaseAPI}
 */
export class SupportApi extends BaseAPI {
    /**
     * 
     * @param {ContactUsDTO} contactUsDTO 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SupportApi
     */
    public supportControllerContactUs(contactUsDTO: ContactUsDTO, options?: RawAxiosRequestConfig) {
        return SupportApiFp(this.configuration).supportControllerContactUs(contactUsDTO, options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * UploadApi - axios parameter creator
 * @export
 */
export const UploadApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Upload an file
         * @param {File} [file] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        imageUploadControllerUploadFile: async (file?: File, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/v1/account/upload/file`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;
            const localVarFormParams = new ((configuration && configuration.formDataCtor) || FormData)();


            if (file !== undefined) { 
                localVarFormParams.append('file', file as any);
            }
    
    
            localVarHeaderParameter['Content-Type'] = 'multipart/form-data';
    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = localVarFormParams;

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Upload an image with optional resizing
         * @param {ImageUploadControllerUploadImageTypeEnum} [type] 
         * @param {File} [file] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        imageUploadControllerUploadImage: async (type?: ImageUploadControllerUploadImageTypeEnum, file?: File, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/v1/account/upload/image`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;
            const localVarFormParams = new ((configuration && configuration.formDataCtor) || FormData)();

            if (type !== undefined) {
                localVarQueryParameter['type'] = type;
            }


            if (file !== undefined) { 
                localVarFormParams.append('file', file as any);
            }
    
    
            localVarHeaderParameter['Content-Type'] = 'multipart/form-data';
    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = localVarFormParams;

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * UploadApi - functional programming interface
 * @export
 */
export const UploadApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = UploadApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @summary Upload an file
         * @param {File} [file] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async imageUploadControllerUploadFile(file?: File, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<FileUploadResult>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.imageUploadControllerUploadFile(file, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['UploadApi.imageUploadControllerUploadFile']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Upload an image with optional resizing
         * @param {ImageUploadControllerUploadImageTypeEnum} [type] 
         * @param {File} [file] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async imageUploadControllerUploadImage(type?: ImageUploadControllerUploadImageTypeEnum, file?: File, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<FileUploadResult>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.imageUploadControllerUploadImage(type, file, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['UploadApi.imageUploadControllerUploadImage']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * UploadApi - factory interface
 * @export
 */
export const UploadApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = UploadApiFp(configuration)
    return {
        /**
         * 
         * @summary Upload an file
         * @param {File} [file] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        imageUploadControllerUploadFile(file?: File, options?: RawAxiosRequestConfig): AxiosPromise<FileUploadResult> {
            return localVarFp.imageUploadControllerUploadFile(file, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Upload an image with optional resizing
         * @param {ImageUploadControllerUploadImageTypeEnum} [type] 
         * @param {File} [file] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        imageUploadControllerUploadImage(type?: ImageUploadControllerUploadImageTypeEnum, file?: File, options?: RawAxiosRequestConfig): AxiosPromise<FileUploadResult> {
            return localVarFp.imageUploadControllerUploadImage(type, file, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * UploadApi - object-oriented interface
 * @export
 * @class UploadApi
 * @extends {BaseAPI}
 */
export class UploadApi extends BaseAPI {
    /**
     * 
     * @summary Upload an file
     * @param {File} [file] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UploadApi
     */
    public imageUploadControllerUploadFile(file?: File, options?: RawAxiosRequestConfig) {
        return UploadApiFp(this.configuration).imageUploadControllerUploadFile(file, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Upload an image with optional resizing
     * @param {ImageUploadControllerUploadImageTypeEnum} [type] 
     * @param {File} [file] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UploadApi
     */
    public imageUploadControllerUploadImage(type?: ImageUploadControllerUploadImageTypeEnum, file?: File, options?: RawAxiosRequestConfig) {
        return UploadApiFp(this.configuration).imageUploadControllerUploadImage(type, file, options).then((request) => request(this.axios, this.basePath));
    }
}

/**
 * @export
 */
export const ImageUploadControllerUploadImageTypeEnum = {
    Thumbnail: 'thumbnail',
    Logo: 'logo',
    ProductImage: 'product-image',
    CoverImage: 'cover-image',
    Medium: 'medium',
    Large: 'large'
} as const;
export type ImageUploadControllerUploadImageTypeEnum = typeof ImageUploadControllerUploadImageTypeEnum[keyof typeof ImageUploadControllerUploadImageTypeEnum];


/**
 * UserListApi - axios parameter creator
 * @export
 */
export const UserListApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Add an item to a user\'s list
         * @param {AddListItemDTO} addListItemDTO 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listItemControllerAddItemToList: async (addListItemDTO: AddListItemDTO, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'addListItemDTO' is not null or undefined
            assertParamExists('listItemControllerAddItemToList', 'addListItemDTO', addListItemDTO)
            const localVarPath = `/v1/account/list-items`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(addListItemDTO, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get all list items for the current user
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listItemControllerGetUserList: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/v1/account/list-items`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Remove an item from a user\'s list
         * @param {number} itemId ID of the list item to remove
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listItemControllerRemoveItemFromList: async (itemId: number, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'itemId' is not null or undefined
            assertParamExists('listItemControllerRemoveItemFromList', 'itemId', itemId)
            const localVarPath = `/v1/account/list-items/{itemId}`
                .replace(`{${"itemId"}}`, encodeURIComponent(String(itemId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * UserListApi - functional programming interface
 * @export
 */
export const UserListApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = UserListApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @summary Add an item to a user\'s list
         * @param {AddListItemDTO} addListItemDTO 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async listItemControllerAddItemToList(addListItemDTO: AddListItemDTO, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ListItemInfo>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.listItemControllerAddItemToList(addListItemDTO, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['UserListApi.listItemControllerAddItemToList']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Get all list items for the current user
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async listItemControllerGetUserList(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<ListItemInfo>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.listItemControllerGetUserList(options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['UserListApi.listItemControllerGetUserList']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Remove an item from a user\'s list
         * @param {number} itemId ID of the list item to remove
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async listItemControllerRemoveItemFromList(itemId: number, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.listItemControllerRemoveItemFromList(itemId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['UserListApi.listItemControllerRemoveItemFromList']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * UserListApi - factory interface
 * @export
 */
export const UserListApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = UserListApiFp(configuration)
    return {
        /**
         * 
         * @summary Add an item to a user\'s list
         * @param {AddListItemDTO} addListItemDTO 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listItemControllerAddItemToList(addListItemDTO: AddListItemDTO, options?: RawAxiosRequestConfig): AxiosPromise<ListItemInfo> {
            return localVarFp.listItemControllerAddItemToList(addListItemDTO, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get all list items for the current user
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listItemControllerGetUserList(options?: RawAxiosRequestConfig): AxiosPromise<Array<ListItemInfo>> {
            return localVarFp.listItemControllerGetUserList(options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Remove an item from a user\'s list
         * @param {number} itemId ID of the list item to remove
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listItemControllerRemoveItemFromList(itemId: number, options?: RawAxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.listItemControllerRemoveItemFromList(itemId, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * UserListApi - object-oriented interface
 * @export
 * @class UserListApi
 * @extends {BaseAPI}
 */
export class UserListApi extends BaseAPI {
    /**
     * 
     * @summary Add an item to a user\'s list
     * @param {AddListItemDTO} addListItemDTO 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UserListApi
     */
    public listItemControllerAddItemToList(addListItemDTO: AddListItemDTO, options?: RawAxiosRequestConfig) {
        return UserListApiFp(this.configuration).listItemControllerAddItemToList(addListItemDTO, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get all list items for the current user
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UserListApi
     */
    public listItemControllerGetUserList(options?: RawAxiosRequestConfig) {
        return UserListApiFp(this.configuration).listItemControllerGetUserList(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Remove an item from a user\'s list
     * @param {number} itemId ID of the list item to remove
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UserListApi
     */
    public listItemControllerRemoveItemFromList(itemId: number, options?: RawAxiosRequestConfig) {
        return UserListApiFp(this.configuration).listItemControllerRemoveItemFromList(itemId, options).then((request) => request(this.axios, this.basePath));
    }
}



